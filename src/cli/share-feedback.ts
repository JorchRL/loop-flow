/**
 * Share Feedback CLI Command
 * 
 * Interactive command to review and share queued feedback specs.
 * Options:
 * - Interactive: Review each item and create GitHub issues
 * - Export: Write all queued feedback to a markdown file for manual sharing
 */

import * as readline from "readline";
import * as fs from "fs";
import * as path from "path";
import { exec } from "child_process";
import { promisify } from "util";
import { initializeDatabase } from "../db/database.js";
import type { FeedbackSpecRecord } from "../db/repositories/feedback-specs.js";

const execAsync = promisify(exec);

// LoopFlow GitHub repo for issues
const LOOPFLOW_REPO = "anomalyco/loop-flow";

interface ShareFeedbackOptions {
  repoPath: string;
  dryRun?: boolean;
  export?: string; // Export to file instead of interactive mode
}

/**
 * Create a readline interface for user input
 */
function createReadline(): readline.Interface {
  return readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
}

/**
 * Prompt user for input
 */
async function prompt(rl: readline.Interface, question: string): Promise<string> {
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      resolve(answer.trim());
    });
  });
}

/**
 * Check if gh CLI is available and authenticated
 */
async function checkGhCli(): Promise<{ available: boolean; authenticated: boolean; error?: string }> {
  try {
    await execAsync("gh --version");
  } catch {
    return {
      available: false,
      authenticated: false,
      error: "GitHub CLI (gh) is not installed. Install from https://cli.github.com/",
    };
  }

  try {
    await execAsync("gh auth status");
    return { available: true, authenticated: true };
  } catch {
    return {
      available: true,
      authenticated: false,
      error: "GitHub CLI is not authenticated. Run 'gh auth login' first.",
    };
  }
}

/**
 * Create a GitHub issue for a feedback spec
 */
async function createGitHubIssue(spec: FeedbackSpecRecord): Promise<{ url: string } | { error: string }> {
  const typeLabel = spec.type === "pain_point" ? "pain-point" : 
                    spec.type === "feature_idea" ? "enhancement" : "bug";
  
  const severityLabel = spec.severity === "critical" ? "priority: critical" :
                        spec.severity === "high" ? "priority: high" : undefined;

  // Build issue body
  const bodyParts = [
    `## Description`,
    spec.description,
    ``,
    `## Details`,
    `- **Type**: ${spec.type.replace("_", " ")}`,
    `- **Severity**: ${spec.severity}`,
    `- **Captured**: ${spec.created_at}`,
    `- **Source ID**: ${spec.id}`,
  ];

  if (spec.context_summary) {
    bodyParts.push(``, `## Context (sanitized)`, spec.context_summary);
  }

  bodyParts.push(``, `---`, `*This issue was generated by LoopFlow's feedback system.*`);

  const body = bodyParts.join("\n");

  // Build gh command
  const labels = [typeLabel, severityLabel].filter(Boolean).join(",");
  const title = spec.title.replace(/"/g, '\\"');
  
  try {
    const { stdout } = await execAsync(
      `gh issue create --repo "${LOOPFLOW_REPO}" --title "${title}" --body "${body.replace(/"/g, '\\"').replace(/\n/g, "\\n")}" --label "${labels}"`,
      { maxBuffer: 1024 * 1024 }
    );
    
    // gh issue create outputs the URL
    const url = stdout.trim();
    return { url };
  } catch (error) {
    return { error: error instanceof Error ? error.message : String(error) };
  }
}

/**
 * Display a feedback spec for review
 */
function displaySpec(spec: FeedbackSpecRecord, index: number, total: number): void {
  console.log(`\n${"=".repeat(60)}`);
  console.log(`Feedback ${index + 1}/${total}: ${spec.id}`);
  console.log(`${"=".repeat(60)}`);
  console.log(`Type:     ${spec.type.replace("_", " ")}`);
  console.log(`Severity: ${spec.severity}`);
  console.log(`Title:    ${spec.title}`);
  console.log(`\nDescription:`);
  console.log(`  ${spec.description.split("\n").join("\n  ")}`);
  if (spec.context_summary) {
    console.log(`\nContext (sanitized):`);
    console.log(`  ${spec.context_summary.split("\n").join("\n  ")}`);
  }
  console.log(`\nCreated: ${spec.created_at}`);
}

/**
 * Format a feedback spec as markdown
 */
function formatSpecAsMarkdown(spec: FeedbackSpecRecord): string {
  const lines = [
    `## ${spec.title}`,
    ``,
    `**ID:** ${spec.id}  `,
    `**Type:** ${spec.type.replace("_", " ")}  `,
    `**Severity:** ${spec.severity}  `,
    `**Captured:** ${spec.created_at}`,
    ``,
    `### Description`,
    ``,
    spec.description,
  ];

  if (spec.context_summary) {
    lines.push(``, `### Context (sanitized)`, ``, spec.context_summary);
  }

  lines.push(``, `---`, ``);
  return lines.join("\n");
}

/**
 * Export all queued feedback to a markdown file
 */
export async function exportFeedback(options: { repoPath: string; outputPath: string }): Promise<{ success: boolean; count: number; path: string }> {
  const { repoPath, outputPath } = options;
  
  const db = initializeDatabase(repoPath);
  const queued = db.feedbackSpecs.findAll({ statuses: ["queued"] });
  
  if (queued.length === 0) {
    console.log("\nNo queued feedback to export.");
    db.close();
    return { success: true, count: 0, path: outputPath };
  }

  const lines = [
    `# LoopFlow Feedback Report`,
    ``,
    `Generated: ${new Date().toISOString()}  `,
    `Items: ${queued.length}`,
    ``,
    `> This report was generated by LoopFlow's feedback system.`,
    `> Context has been sanitized to remove potentially sensitive information.`,
    `> Please review before sharing.`,
    ``,
    `---`,
    ``,
  ];

  for (const spec of queued) {
    lines.push(formatSpecAsMarkdown(spec));
  }

  // Resolve output path
  const resolvedPath = path.isAbsolute(outputPath) 
    ? outputPath 
    : path.join(repoPath, outputPath);

  // Ensure directory exists
  const dir = path.dirname(resolvedPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(resolvedPath, lines.join("\n"));
  
  console.log(`\nExported ${queued.length} feedback item(s) to: ${resolvedPath}`);
  console.log("\nYou can:");
  console.log("  - Review and edit the file before sharing");
  console.log("  - Share via email, Discord, or other channels");
  console.log("  - Create GitHub issues manually from the content\n");

  db.close();
  return { success: true, count: queued.length, path: resolvedPath };
}

/**
 * Main share-feedback command
 */
export async function shareFeedback(options: ShareFeedbackOptions): Promise<{ success: boolean; shared: number; dismissed: number; skipped: number; exported?: number }> {
  const { repoPath, dryRun = false } = options;
  
  // If export mode, just export and return
  if (options.export) {
    const result = await exportFeedback({ repoPath, outputPath: options.export });
    return { success: result.success, shared: 0, dismissed: 0, skipped: 0, exported: result.count };
  }
  
  // Check gh CLI
  const ghStatus = await checkGhCli();
  if (!ghStatus.available || !ghStatus.authenticated) {
    console.error(`\nError: ${ghStatus.error}`);
    if (!dryRun) {
      console.log("\nTip: Use --export <file> to export feedback to a file instead.\n");
      return { success: false, shared: 0, dismissed: 0, skipped: 0 };
    }
    console.log("\n(Continuing in dry-run mode...)\n");
  }

  // Initialize database
  const db = initializeDatabase(repoPath);
  
  // Get queued feedback
  const queued = db.feedbackSpecs.findAll({ statuses: ["queued"] });
  
  if (queued.length === 0) {
    console.log("\nNo queued feedback to share.");
    console.log("Use loop_painpoint in an AI session to capture feedback.\n");
    db.close();
    return { success: true, shared: 0, dismissed: 0, skipped: 0 };
  }

  console.log(`\nFound ${queued.length} queued feedback item(s) to review.\n`);
  console.log("For each item, you can:");
  console.log("  [s] Share - Create a GitHub issue");
  console.log("  [e] Edit  - Modify before sharing");
  console.log("  [d] Dismiss - Remove without sharing");
  console.log("  [k] Skip  - Leave queued for later");
  console.log("  [q] Quit  - Stop reviewing\n");

  const rl = createReadline();
  let shared = 0;
  let dismissed = 0;
  let skipped = 0;

  try {
    for (let i = 0; i < queued.length; i++) {
      const spec = queued[i];
      displaySpec(spec, i, queued.length);

      let validAction = false;
      while (!validAction) {
        const action = await prompt(rl, "\nAction [s/e/d/k/q]: ");
        
        switch (action.toLowerCase()) {
          case "s": // Share
          case "share":
            if (dryRun) {
              console.log("\n[DRY RUN] Would create GitHub issue:");
              console.log(`  Repo: ${LOOPFLOW_REPO}`);
              console.log(`  Title: ${spec.title}`);
              shared++;
            } else {
              console.log("\nCreating GitHub issue...");
              const result = await createGitHubIssue(spec);
              if ("url" in result) {
                console.log(`Created: ${result.url}`);
                db.feedbackSpecs.update(spec.id, {
                  status: "shared",
                  shared_at: new Date().toISOString(),
                  github_issue_url: result.url,
                });
                shared++;
              } else {
                console.error(`Failed to create issue: ${result.error}`);
                console.log("Leaving as queued for retry.");
                skipped++;
              }
            }
            validAction = true;
            break;

          case "e": // Edit
          case "edit":
            console.log("\n(Editing not yet implemented - skipping for now)");
            // TODO: Allow editing title/description before sharing
            skipped++;
            validAction = true;
            break;

          case "d": // Dismiss
          case "dismiss":
            if (dryRun) {
              console.log("\n[DRY RUN] Would dismiss feedback");
            } else {
              db.feedbackSpecs.update(spec.id, { status: "dismissed" });
              console.log("\nFeedback dismissed.");
            }
            dismissed++;
            validAction = true;
            break;

          case "k": // Skip
          case "skip":
            console.log("\nSkipping (will remain queued).");
            skipped++;
            validAction = true;
            break;

          case "q": // Quit
          case "quit":
            console.log("\nStopping review. Remaining items will stay queued.\n");
            skipped += queued.length - i;
            rl.close();
            db.close();
            return { success: true, shared, dismissed, skipped };

          default:
            console.log("Invalid action. Use s (share), e (edit), d (dismiss), k (skip), or q (quit).");
        }
      }
    }
  } finally {
    rl.close();
  }

  console.log(`\n${"=".repeat(60)}`);
  console.log("Review complete!");
  console.log(`  Shared:    ${shared}`);
  console.log(`  Dismissed: ${dismissed}`);
  console.log(`  Skipped:   ${skipped}`);
  console.log(`${"=".repeat(60)}\n`);

  db.close();
  return { success: true, shared, dismissed, skipped };
}
